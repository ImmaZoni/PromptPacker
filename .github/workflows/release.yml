name: Create Release and Build Binaries

# Trigger the workflow on pushes to tags matching v*.*.* (e.g., v0.1.0, v1.0.0)
on:
  push:
    tags:
      - 'v*' # Matches tags like v1.0, v1.2.3, v0.1.0-beta

# Define permissions required for the workflow to create releases and upload assets
permissions:
  contents: write # Required to create releases and upload release assets

jobs:
  # Job 1: Build binaries for different OS/Arch combinations
  build:
    name: Build Binaries
    runs-on: ubuntu-latest # Use a standard Linux runner for building
    strategy:
      matrix:
        # Define the build targets
        include:
          - goos: linux
            goarch: amd64
            output_suffix: linux-amd64
          - goos: linux
            goarch: arm64
            output_suffix: linux-arm64
          - goos: windows
            goarch: amd64
            output_suffix: windows-amd64.exe # Add .exe suffix for Windows
          - goos: darwin # macOS
            goarch: amd64
            output_suffix: darwin-amd64
          - goos: darwin # macOS Apple Silicon
            goarch: arm64
            output_suffix: darwin-arm64
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21' # Specify your Go version (or use go-version-file if you have go.mod)

      - name: Build for ${{ matrix.goos }}/${{ matrix.goarch }}
        # Set GOOS and GOARCH environment variables for cross-compilation
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          # Define the output binary name including OS/Arch suffix
          BINARY_NAME="promptpacker-${{ matrix.output_suffix }}"
          echo "Building ${BINARY_NAME}..."
          # Build command with optimizations (-s -w strips debug info, making binary smaller)
          go build -o "${BINARY_NAME}" -ldflags="-s -w" PromptPacker.go
          echo "Build complete: ${BINARY_NAME}"

      # Temporarily upload the built binary as an artifact for the release job to use
      - name: Upload artifact (${{ matrix.output_suffix }})
        uses: actions/upload-artifact@v4
        with:
          name: promptpacker-binaries # Use a consistent artifact name across matrix runs
          path: promptpacker-${{ matrix.output_suffix }} # Path to the binary file just built
          if-no-files-found: error # Fail if the binary wasn't created

  # Job 2: Create the GitHub Release and upload all built binaries
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build # This job runs only after the 'build' job completes successfully for ALL matrix configs
    # Optional: Add condition to double-check it's a tag event (belt-and-suspenders)
    # if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout code (optional, needed if release notes use files)
        uses: actions/checkout@v4

      # Download all artifacts (binaries) built in the previous job's matrix
      # They will be placed in the 'dist' directory
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          name: promptpacker-binaries # Must match the upload artifact name
          path: dist # Directory to download artifacts into

      # List files to verify download (optional debug step)
      - name: List downloaded files
        run: ls -R dist

      # Use softprops/action-gh-release to create the release and upload files
      # It automatically uses the tag name and can generate release notes
      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          # Use the tag name that triggered the workflow for the release tag
          tag_name: ${{ github.ref_name }}
          # Name the release using the tag name
          name: Release ${{ github.ref_name }}
          # Automatically generate release notes from commits since the last tag
          generate_release_notes: true
          # Use a glob pattern to upload all downloaded binaries from the 'dist' directory
          files: dist/*
        env:
          # The GITHUB_TOKEN is automatically provided by GitHub Actions
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}